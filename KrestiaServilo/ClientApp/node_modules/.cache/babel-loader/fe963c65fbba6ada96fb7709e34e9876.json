{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n}; // get vertical offsets of element, taking scrollTop into consideration\n\n\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _element$getBoundingC = element.getBoundingClientRect(),\n      top = _element$getBoundingC.top,\n      bottom = _element$getBoundingC.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n}; // does scrollTop live within element bounds?\n\n\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n}; // is el2's location more relevant than el2,\n// parent-child relationship aside?\n\n\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    } // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n\n\n    return bottom2 < bottom1;\n  } // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n\n\n  return top2 > top1;\n}; // check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\n\n\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n\n  return false;\n}; // given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\n\n\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id];\n\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};","map":{"version":3,"sources":["D:/Projects/Krestia/KrestiaServilo/ClientApp/.yarn/$$virtual/react-scrollable-anchor-virtual-8625232b1b/0/cache/react-scrollable-anchor-npm-0.6.1-43a3e7539e-a86939f348.zip/node_modules/react-scrollable-anchor/lib/utils/scroll.js"],"names":["Object","defineProperty","exports","value","getScrollTop","document","body","scrollTop","documentElement","getElementOffset","element","_element$getBoundingC","getBoundingClientRect","top","bottom","Math","floor","doesElementContainScrollTop","extraOffset","arguments","length","undefined","offsetTop","offsetHeight","checkLocationRelevance","el1","el2","_getElementOffset","top1","bottom1","_getElementOffset2","top2","bottom2","checkElementRelevance","contains","getBestAnchorGivenScrollLocation","anchors","offset","bestId","bestElement","keys","forEach","id"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar getScrollTop = exports.getScrollTop = function getScrollTop() {\n  return document.body.scrollTop || document.documentElement.scrollTop;\n};\n\n// get vertical offsets of element, taking scrollTop into consideration\nvar getElementOffset = exports.getElementOffset = function getElementOffset(element) {\n  var scrollTop = getScrollTop();\n\n  var _element$getBoundingC = element.getBoundingClientRect(),\n      top = _element$getBoundingC.top,\n      bottom = _element$getBoundingC.bottom;\n\n  return {\n    top: Math.floor(top + scrollTop),\n    bottom: Math.floor(bottom + scrollTop)\n  };\n};\n\n// does scrollTop live within element bounds?\nvar doesElementContainScrollTop = exports.doesElementContainScrollTop = function doesElementContainScrollTop(element) {\n  var extraOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var scrollTop = getScrollTop();\n  var offsetTop = getElementOffset(element).top + extraOffset;\n  return scrollTop >= offsetTop && scrollTop < offsetTop + element.offsetHeight;\n};\n\n// is el2's location more relevant than el2,\n// parent-child relationship aside?\nvar checkLocationRelevance = exports.checkLocationRelevance = function checkLocationRelevance(el1, el2) {\n  var _getElementOffset = getElementOffset(el1),\n      top1 = _getElementOffset.top,\n      bottom1 = _getElementOffset.bottom;\n\n  var _getElementOffset2 = getElementOffset(el2),\n      top2 = _getElementOffset2.top,\n      bottom2 = _getElementOffset2.bottom;\n\n  if (top1 === top2) {\n    if (bottom1 === bottom2) {\n      // top and bottom of compared elements are the same,\n      // so return one randomly in a deterministic way\n      return el1 < el2;\n    }\n    // top of compared elements is the same, so return whichever\n    // element has its bottom higher on the page\n    return bottom2 < bottom1;\n  }\n  // top of compared elements differ, so return true\n  // if tested element has its top lower on the page\n  return top2 > top1;\n};\n\n// check if el2 is more relevant than el1, considering child-parent\n// relationships as well as node location.\nvar checkElementRelevance = exports.checkElementRelevance = function checkElementRelevance(el1, el2) {\n  if (el1.contains(el2)) {\n    // el2 is child, so it gains relevance priority\n    return true;\n  } else if (!el2.contains(el1) && checkLocationRelevance(el1, el2)) {\n    // el1 and el2 are unrelated, but el2 has a better location,\n    // so it gains relevance priority\n    return true;\n  }\n  return false;\n};\n\n// given a set of anchors, find which one is, given the following logic:\n// 1. children nodes are more relevant than parent nodes\n// 2. if neither node contains the other, and their top locations differ,\n//    the node with the top lower on the page is more relevant\n// 3. if neither node contains the other, and their top locations are the same,\n//    the node with the bottom higher on the page is more relevant\n// 4. if neither node contains the other, and their top and bottom locations\n//    are the same, a node is chosen at random, in a deterministic way,\n//    to be more relevant.\nvar getBestAnchorGivenScrollLocation = exports.getBestAnchorGivenScrollLocation = function getBestAnchorGivenScrollLocation(anchors, offset) {\n  var bestId = void 0,\n      bestElement = void 0;\n\n  Object.keys(anchors).forEach(function (id) {\n    var element = anchors[id];\n    if (doesElementContainScrollTop(element, offset)) {\n      if (!bestElement || checkElementRelevance(bestElement, element)) {\n        bestElement = element;\n        bestId = id;\n      }\n    }\n  });\n  return bestId;\n};"]},"metadata":{},"sourceType":"script"}